# 操作系统第二次实验报告
李曌珩 2017050025 计74

## 练习1
### 设计实现过程
1. 复用`default_init() default_init_memmap() default_nr_free_pages()`函数
2. 修改`default_alloc_pages()`函数，先判断当前链表中是否还有满足条件的空闲页块，如果找到了适合的空闲页块，在链表中插入新的页块，设置属性`p->property = page->property - n`，然后删除该页块，更新`nr_free`的值。
3. 修改`default_free_pages()`函数，遍历整个链表找到插入位置，插入该页块并更新`nr_free`的值。

### 你的 first fit 算法是否有进一步的改进空间
使用该算法做页块的分配和回收，大部分开销都在对双向链表的遍历上，如果使用更加高级、有效的数据结构来维护页块的使用情况，可以降低算法的复杂度，提高查找速度，例如B树。

## 练习2
### 设计实现过程
文件中给出了详细的注释，翻译注释实现代码如下：
```c
pde_t *pdep = pgdir + PDX(la);
    if ((*pdep & PTE_P) == 0) {
        if (create) {
            struct Page *p = alloc_page();
            if (p==NULL) return NULL;
            set_page_ref(p, 1);
            uintptr_t pa = page2pa(p);
            memset(KADDR(pa), 0, PGSIZE);
            *pdep = (pa & ~0x0fff) | PTE_USER;
        } else return NULL;
    }
    return (pte_t*)KADDR(PDE_ADDR(*pdep)) + PTX(la);
```

### 请描述页目录项（Page Directory Entry）和页表项（Page Table Entry）中每个组成部分的含义以及对 ucore 而言的潜在用处。

在文件`mmu.h`中可以看到PDE和PTE各部位组成相同，具体如下：

| 位    | 名称  | 含义                                                      |
| ----- | ----- | ---------------------------------------------------------|
| 0     | P     | 当前页面是否在内存中                                        |
| 1     | W     | 当前页面是否可写                                           |
| 2     | U     | 0表示页表中任何页面只能内核态访问，否则用户态可能可以访问         |
| 3     | PWT   | 1表示缓存Write Through，否则Write Back                     |
| 4     | PCD   | 1表示不缓存，否则缓存                                       |
| 5     | A     | 在上次清零之后，该页是否被读写过                              |
| 6     | D     | 在上次清零之后，该页是否被写过                                |
| 7     | PS    | 页大小，1为4MB，0为4KB。（ucore强制设为0）                       |
| 7-8   | MBZ   | 必须为0                                                   |
| 9-11  | AVAIL | 提供给用户程序使用                                          |
| 12-31 | INDEX | 页基址                                                    |


### 如果 ucore 执行过程中访问内存，出现了页访问异常，请问硬件要做哪些事情？

CPU会进行下面的操作：

1. 保存现场，存储当前的寄存器到主存储器中；
2. 设置相应的寄存器CR2记录当前出错程序的地址信息，记录页面访问异常类型；
3. 切换特权级；
4. 根据异常号读取IDT表，确定ISR的地址，判断是否有进入中断门的权限；
5. 跳转到ISR起始地址开始执行中断服务例程。

如果当前已经处于页访问异常的处理例程中，又发生了页访问异常，这对CPU来说是不允许的，这种情况往往说明操作系统编码出现问题。

## 练习3
### 设计实现过程
文件中给出了详细的注释，翻译注释实现代码如下：
```c
if (*ptep & PTE_P) {
        struct Page *page = pte2page(*ptep);
        page_ref_dec(page);
        if (page->ref == 0) { free_page(page); }
        *ptep = 0;
        tlb_invalidate(pgdir, la);
    }
```
### 数据结构 Page 的全局变量（其实是一个数组）的每一项与页表中的页目录项和页表项有无对应关系？如果有，其对应关系是啥？
Page数组主要用于管理物理的连续内存，数组中每一个Page对应物理内存中的一个页。
页目录存在物理内存的页中，其每一项指向的页表也存储在物理内存的页中。
页表中每一项存储的是页的物理内存地址，通过这个地址能够找到与之对应的Page结构。

三者的高20位都表示的是物理页号，通常情况下，页表中的页目录项和页表项中的物理页号可对应于Page中的某一项，但也有可能出现不对应任何物理页的情况。



### 如果希望虚拟地址与物理地址相等，则需要如何修改 lab2，完成此事？
ucore 在启动过程中会先后启用段机制、启用页机制、更换段机制。整个过程中uCore都必须保证正确的地址映射关系。前期uCore主要使用段机制进行地址偏移、后期uCore则使用页机制进行地址偏移。如果要使得虚拟地址与物理地址相等，需要进行如下操作：

1. 在`Bootloader`阶段，线性地址与物理地址相等，无需修改；

2. 在启用段机制的过程中，需要修改的地方为`init/entry.S`中的gdt表项，去除`KERNBASE`有关的定义。此外，还需要修改ucore的链接脚本，将ucore起始的虚拟地址由`0xC0100000`改为`0x00100000`。修改 `kern/mm/memlayout.h` 中的 `KERNBASE` 为 `0x00000000`，修改 `tools/kernel.ld` 中的基址为 `0x00100000`。

3. 之后的阶段虽然启动了页机制但是未更新段映射，这个时候页机制和段机制对于`0xC0000000`的偏移是叠加的。由于上一阶段已经修改过段机制的代码，这里取消了VPT的递归自映射，这种情况下没有必要专门建立0-4M物理地址映射，修改 `kern/init/entry.S` 中的代码，删除关于0-4M地址空间的映射操作。

4. 之后的阶段由于完全启用了页机制，且页机制的相关参数已经在上一步设置完毕，所以无需修改，虚拟地址自会与物理地址相等。

5. 最后为了通过测试需要修改 `kern/mm/pmm.c` 中的一些地址编码。

代码在同仓库的`lab2-ex3``分枝下。

## 总结
### 本实验中重要的知识点，以及与对应的OS原理中的知识点

1. 首次匹配
2. x86分页机制
3. 二级页表

### 本实验中没有对应的

1. 最佳匹配
2. 最差匹配
3. 碎片整理
4. 反置页表
